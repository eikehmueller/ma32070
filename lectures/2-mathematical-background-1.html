<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mathematical background</title>
  <style>
    div.sitenav { display: flex; flex-direction: row; flex-wrap: wrap; }
    span.navlink { flex: 1; }
    span.navlink-label { display: inline-block; min-width: 4em; }
    html {
      font-family: arial;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 80%;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: blue;
    }
    a:visited {
      color: blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<nav id="sitenav">
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Up:</span> <a href="index.html" accesskey="u" rel="up"></a>
</span>
<span class="navlink">
<span class="navlink-label">Top:</span> <a href="index.html" accesskey="t" rel="top"></a>
</span>
</div>
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Next:</span> <a href="3-finite-elements.html" accesskey="n" rel="next">Finite Elements</a>
</span>
<span class="navlink">
<span class="navlink-label">Previous:</span> <a href="1-prerequisites-and-references.html" accesskey="p" rel="previous">Prerequisites and References</a>
</span>
</div>
</nav>
<h1 data-number="2" id="mathematical-background-1">Mathematical
background</h1>
<p>In the following we will give a first overview of the finite element
method and review some of the fundamental ideas as to why it works. The
details will be discuss in later lectures.</p>
<p><em>© Eike Mueller, University of Bath 2025. These lecture notes are
copyright of Eike Mueller, University of Bath. They are provided
exclusively for educational purposes at the University and are to be
downloaded or copied for your private study only. Further distribution,
e.g. by upload to external repositories, is prohibited.</em> ## Model
problem In this course we will focus on the following partial
differential equation (PDE) of the diffusion-reaction type in some
bounded domain <span class="math inline">\(\Omega\subset
\mathbb{R}^2\)</span>: <span class="math display">\[
-\nabla \cdot (\kappa \nabla  u(x)) + \omega\; u(x) = f(x) \qquad
\text{for $x\in \Omega$}\qquad(\dagger)
\]</span> with boundary condition <span class="math inline">\(\kappa\;
n\cdot \nabla u(x)=g(x)\)</span> for <span
class="math inline">\(x\in\partial \Omega\)</span>. We assume that <span
class="math inline">\(\omega, \kappa&gt;0\)</span> are positive
constants and <span class="math inline">\(f(x)\)</span>, <span
class="math inline">\(g(x)\)</span> are given functions. Using
zero-based indexing (as is used in Python) we will write <span
class="math inline">\(x=(x_0,x_1)\in\mathbb{R}^2\)</span> such that
<span class="math inline">\(\nabla=(\frac{\partial}{\partial
x_0},\frac{\partial}{\partial x_1})^\top\)</span> is the nabla-operator.
Note that in the case <span class="math inline">\(\kappa=1\)</span>,
<span class="math inline">\(\omega=0\)</span> the problem would reduce
to the Poisson equation <span class="math inline">\(-\Delta
u(x)=f(x)\)</span>. Unfortunately, for the given boundary condition the
solution of the Poisson equation is not unique (if <span
class="math inline">\(u(x)\)</span> is a solution then so is <span
class="math inline">\(u(x)+C\)</span> for an arbitrary constant <span
class="math inline">\(C\)</span>), which is why we do not consider this
case here. However, the methods developed in this course can be readily
applied to this setup, provided we extend them to treat Dirichlet
boundary conditions of the form <span
class="math inline">\(u(x)=\widetilde{g}(x)\)</span> for <span
class="math inline">\(x\in\partial \Omega\)</span> and some given
function <span class="math inline">\(\widetilde{g}(x)\)</span>.</p>
<h2 data-number="2.1" id="weak-solutions">Weak solutions</h2>
<p>To solve <span class="math inline">\((\dagger)\)</span>, we seek
solutions <span class="math inline">\(u(x)\)</span> in some function
space <span class="math inline">\(\mathcal{V}\)</span>. In the following
we choose <span class="math inline">\(\mathcal{V}:=H^1(\Omega)\subset
L_2(\Omega)\)</span>, which is the space of all real-valued functions on
<span class="math inline">\(\Omega\)</span> which have a
square-integrable first derivative. More specifically, define the
following two norms <span class="math display">\[
\begin{aligned}
\| u\|_{L_2(\Omega)} &amp;:= \left(\int_\Omega
u(x)^2\;dx\right)^{\frac{1}{2}}\\
\| u\|_{\mathcal{V}} = \| u\|_{H^1(\Omega)} &amp;:= \left(\int_\Omega
\left(u(x)^2+|\nabla u|^2\right)\;dx\right)^{\frac{1}{2}}
\end{aligned}
\]</span> and then set <span class="math inline">\(L_2(\Omega) =
\left\{u(x) : ||u||_{L_2(\Omega)}&lt;\infty\right\}\)</span> (the space
of square-integrable real functions) and <span
class="math inline">\(H^1(\Omega) = \left\{u(x) :
||u||_{H_1(\Omega)}&lt;\infty\right\}\)</span>. Since in <span
class="math inline">\((\dagger)\)</span> two derivatives act on <span
class="math inline">\(u(x)\)</span>, we can only determine the solution
in the <strong>weak sense</strong>: Find <span
class="math inline">\(u(x)\in \mathcal{V}\)</span> such that <span
class="math display">\[
\int_\Omega \left(-v(x)\nabla \cdot(\kappa \nabla  u(x)) + \omega\; v(x)
u(x)\right)\;dx = \int_\Omega f(x) v(x)\;dx \qquad \text{for all
$v(x)\in \mathcal{V}$}.
\]</span> Note that in contrast to <span
class="math inline">\((\dagger)\)</span> we no longer require that the
equation is satisfied at every point <span
class="math inline">\(x\)</span>. Discussing in which sense these weak
solutions are equivalent to solutions of <span
class="math inline">\((\dagger)\)</span> (which is sometimes also
referred to as the <strong>“strong”</strong> form of the equation) is
beyond the scope of this course. After integrating the first term under
the integral on the left-hand side by parts, the weak form becomes <span
class="math display">\[
\int_\Omega \left(\kappa \nabla v(x) \cdot \nabla  u(x) + \omega\; v(x)
u(x)\right)\;dx - \int_{\partial \Omega } \kappa\;v(x) n\cdot
\nabla(u)\;ds = \int_\Omega f(x) v(x)\;dx.
\]</span> Crucially, only first derivatives of the solution <span
class="math inline">\(u(x)\)</span> and test function <span
class="math inline">\(v(x)\)</span> are required now. Using the boundary
condition <span class="math inline">\(\kappa\; n\cdot \nabla
u(x)=g(x)\)</span> for <span
class="math inline">\(x\in\partial\Omega\)</span>, we can rewrite this
as <span class="math display">\[
\int_\Omega \left(\kappa \nabla v(x) \cdot \nabla  u(x) + \omega\; v(x)
u(x)\right)\;dx  = \int_\Omega f(x) v(x)\;dx + \int_{\partial \Omega}
g(x) v(x)\;ds.
\]</span> where now only the left hand side depends on the unknown
function <span class="math inline">\(u(x)\)</span>.</p>
<p>Let us define the symmetric <em>bilinear form</em> <span
class="math inline">\(a(\cdot,\cdot): \mathcal{V}\times \mathcal{V}
\rightarrow \mathbb{R}\)</span> with <span class="math display">\[
a(u,v) := \int_\Omega \left(\kappa \nabla v(x) \cdot \nabla  u(x) +
\omega\; v(x) u(x)\right)\;dx
\]</span> and the linear form <span
class="math inline">\(b(\cdot):\mathcal{V}\rightarrow
\mathbb{R}\)</span> with <span class="math display">\[
b(v) := \int_\Omega f(x) v(x)\;dx+ \int_{\partial \Omega} g(x) v(x)\;ds.
\]</span></p>
<h4 data-number="2.1.0.1" id="exercise">Exercise</h4>
<p>Convince yourself that <span
class="math inline">\(a(\cdot,\cdot)\)</span> and <span
class="math inline">\(b(\cdot)\)</span> are indeed (bi-) linear: * <span
class="math inline">\(a(c_1 u^{(1)} + c_2 u^{(2)}_2,v) = c_1
a(u^{(1)},v) + c_2 a(u^{(2)},v)\)</span> for all <span
class="math inline">\(c_1,c_2\in \mathbb{R}\)</span>, <span
class="math inline">\(u^{(1)}, u^{(2)},v \in \mathcal{V}\)</span> *
<span class="math inline">\(a(u,c_1 v^{(1)} + c_2 v^{(2)}_2) = c_1
a(u,v^{(1)}) + c_2 a(u,v^{(2)})\)</span> for all <span
class="math inline">\(c_1,c_2\in \mathbb{R}\)</span>, <span
class="math inline">\(u,v^{(1)}, v^{(2)} \in \mathcal{V}\)</span> *
<span class="math inline">\(b(c_1 v^{(1)} + c_2 v^{(2)}_2)=c_1b(
v^{(1)}) + c_2 b(v^{(2)}_2)\)</span> for all <span
class="math inline">\(c_1,c_2\in \mathbb{R}\)</span>, <span
class="math inline">\(v^{(1)}, v^{(2)} \in \mathcal{V}\)</span></p>
<p>and that <span class="math inline">\(a(\cdot,\cdot)\)</span> is
symmetric: * <span class="math inline">\(a(v,u) = a(u,v)\)</span> for
all <span class="math inline">\(u,v\in \mathcal{V}\)</span></p>
<p>With these (bi-)linear forms, we can formulate the weak problem as
follows: Find <span class="math inline">\(u(x)\in \mathcal{V}\)</span>
such that <span class="math display">\[
a(u,v) = b(v) \qquad \text{for all $v(x)\in
\mathcal{V}$}.\qquad(\ddagger)
\]</span></p>
<h2 data-number="2.2" id="finite-element-solutions">Finite element
solutions</h2>
<p>Now, obviously it is not possible to solve <span
class="math inline">\((\ddagger)\)</span> on a computer since <span
class="math inline">\(\mathcal{V}\)</span> contains infinitely many
functions. Instead, we try to find solutions in a finite-dimensional
subspace <span class="math inline">\(\mathcal{V}_h\subset
\mathcal{V}\)</span>. This could for example be the space of all
functions that are piecewise linear on a given mesh with spacing <span
class="math inline">\(h\)</span>. We will be more precise about what
that means later in this course. In this case the problem becomes: find
<span class="math inline">\(u_h\in \mathcal{V}_h\)</span> such that
<span class="math display">\[
a(u_h,v_h) = b(v_h) \qquad \text{for all $v_h(x)\in \mathcal{V}_h$
}.\qquad(\ddagger_h)
\]</span></p>
<h3 data-number="2.2.1"
id="existence-and-convergence-of-the-solution">Existence and convergence
of the solution</h3>
<p>It can be shown that <span class="math inline">\((\ddagger)\)</span>
and <span class="math inline">\((\ddagger_h)\)</span> have unique
solutions provided the linear form <span
class="math inline">\(b(\cdot)\)</span> and the bilinear form <span
class="math inline">\(a(\cdot,\cdot)\)</span> satisfy the following two
conditions:</p>
<ul>
<li><strong>Boundedness</strong>: there exists some positive constant
<span class="math inline">\(C_+ &gt; 0\)</span> such that <span
class="math display">\[a(u,v) \le C_+ \|u\|_{\mathcal{V}}
\|v\|_{\mathcal{V}} \qquad\text{and}\]</span> <span
class="math display">\[b(v) \le C_+ \|v\|_{\mathcal{V}} \qquad\text{for
all $u,v\in \mathcal{V}$}.\]</span></li>
<li><strong>Coercivity</strong>: there exists some positive constant
<span class="math inline">\(C_- &gt; 0\)</span> such that <span
class="math display">\[
a(u,u) \ge C_- \|u\|_{\mathcal{V}}^2 \qquad\text{for all $u\in
\mathcal{V}$}.
\]</span> It turns out that both conditions are satisfied for the <span
class="math inline">\(a(\cdot,\cdot)\)</span>, <span
class="math inline">\(b(\cdot)\)</span> defined above. Furthermore, the
solutions satisfy <span
class="math inline">\(\|u\|_{\mathcal{V}},\|u_h\|_{\mathcal{V}}\le
C:=C_+/C_-\)</span> and the difference between the solution <span
class="math inline">\(u_h(x)\)</span> of <span
class="math inline">\((\ddagger_h)\)</span> and the solution <span
class="math inline">\(u(x)\)</span> of <span
class="math inline">\((\ddagger)\)</span> can be bounded as follows:
<span class="math display">\[
\|u_h - u\|_{\mathcal{V}} \le C \min_{v_h\in
\mathcal{V}_h}\|u-v_h\|_{\mathcal{V}}.
\]</span> The constant <span class="math inline">\(C\)</span> on the
right hand side is problem specific since it depends on <span
class="math inline">\(a(\cdot,\cdot)\)</span> and <span
class="math inline">\(b(\cdot)\)</span>. In contrast, the term <span
class="math inline">\(\min_{v_h\in
\mathcal{V}_h}\|u-v_h\|_{\mathcal{V}}\)</span> only depends on the
choice of function spaces <span
class="math inline">\(\mathcal{V}\)</span>, <span
class="math inline">\(\mathcal{V}_h\)</span> and describes how well the
function <span class="math inline">\(u(x) \in \mathcal{V}\)</span> can
be approximated by a function <span class="math inline">\(v_h\in
\mathcal{V}_h\)</span>. For a suitable choice of <span
class="math inline">\(\mathcal{V}_h\)</span>, which we will discuss
later, one can show that <span class="math inline">\(\min_{v_h\in
\mathcal{V}_h}\|u-v_h\|_{\mathcal{V}}\le C&#39; h^{2\mu}\)</span> for
some positive integer <span class="math inline">\(\mu\ge 1\)</span> and
positive constant <span class="math inline">\(C&#39;&gt;0\)</span>.
Hence, the finite element solution <span
class="math inline">\(u_h(x)\)</span> converges to the “true” solution
<span class="math inline">\(u(x)\)</span> as the mesh is refined (<span
class="math inline">\(h\rightarrow 0\)</span>): <span
class="math display">\[
\|u_h - u\|_{\mathcal{V}} \le C C&#39; h^{2\mu}.
\]</span> This is why the finite element works: it can be used to
systematically approximate the true solution of the PDE.</li>
</ul>
<h2 data-number="2.3" id="reduction-to-linear-algebra-problem">Reduction
to linear algebra problem</h2>
<p>We now discuss how <span class="math inline">\(u_h\)</span> can be
found in practice. Since <span
class="math inline">\(\mathcal{V}_h\)</span> is finite dimensional, we
can choose a basis <span
class="math inline">\(\{\Phi^{(h)}_k(x)\}_{k=0}^{n-1}\)</span> such that
every function <span class="math inline">\(u_h(x)\in
\mathcal{V}_h\)</span> can be written as <span class="math display">\[
u_h(x) = \sum_{k=0}^{n-1} u^{(h)}_k \Phi^{(h)}_j(x) \qquad\text{for all
$x\in\Omega$.}\qquad(\star)
\]</span> The vector <span
class="math inline">\(\boldsymbol{u}^{(h)}=(u^{(h)}_0,u^{(h)}_1,\dots,u^{(h)}_{n-1})\in\mathbb{R}^n\)</span>
is often referred to as the degrees-of-freedom vector (short:
dof-vector) since its knowledge determines <span
class="math inline">\(u_h(x)\)</span>. Picking <span
class="math inline">\(v_h(x)=\Phi^{(h)}_\ell(x)\)</span> and inserting
the expansion of <span class="math inline">\(u_h(x)\)</span> in <span
class="math inline">\((\star)\)</span> into <span
class="math inline">\((\ddagger_h)\)</span> we obtain <span
class="math display">\[
b^{(h)}_i:=b(\Phi^{(h)}_\ell) = a\left(\sum_{k=0}^{n-1} u^{(h)}_k
\Phi^{(h)}_k,\Phi^{(h)}_\ell\right) =
\sum_{k=0}^{n-1} u^{(h)}_k a\left( \Phi^{(h)}_\ell,\Phi^{(h)}_k\right),
\]</span> where we used the symmetry and bi-linearity of <span
class="math inline">\(a(\cdot,\cdot)\)</span>. Defining the vector <span
class="math inline">\(\boldsymbol{b}^{(h)} :=
(b(\Phi^{(h)}_0),b(\Phi^{(h)}_1,\dots,b(\Phi^{(h)}_{n-1})))\)</span> and
the <span class="math inline">\(n\times n\)</span> matrix <span
class="math inline">\(A^{(h)}\)</span> with <span
class="math inline">\(A^{(h)}_{\ell k}:=
a\left(\Phi^{(h)}_\ell,\Phi^{(h)}_k\right)\)</span> we arrive at the
following linear system for the dof-vector <span
class="math inline">\(\boldsymbol{u}^{(h)}\)</span>: <span
class="math display">\[
A^{(h)} \boldsymbol{u}^{(h)} = \boldsymbol{b}^{(h)}.
\]</span> At this point it is worth stressing that although <span
class="math inline">\(\boldsymbol{u}^{(h)}\)</span> and <span
class="math inline">\(\boldsymbol{b}^{(h)}\)</span> are both vectors in
<span class="math inline">\(\mathbb{R}^n\)</span>, they are constructed
in a fundamentally different way:</p>
<ul>
<li>The dof-vector <span
class="math inline">\(\boldsymbol{u}^{(h)}\)</span> is a so-called
<strong>primal</strong> vector: its components <span
class="math inline">\(u_\ell^{(h)}\)</span> are the expansion
coefficients of the function <span class="math inline">\(u_h(x)\)</span>
in <span class="math inline">\((\star)\)</span>.</li>
<li>In contrast, the right-hand-side vector <span
class="math inline">\(\boldsymbol{b}^{(h)}\)</span> is a so-called
<strong>dual</strong> vector: its components <span
class="math inline">\(b(\Phi_\ell^{(h)})\)</span> are obtained by
evaluating the linear functional <span
class="math inline">\(b(\cdot)\)</span> for the basis functions.</li>
</ul>
<p>The reason for this is that <span
class="math inline">\(b(\cdot)\)</span> is an element of the dual space
<span class="math inline">\(\mathcal{V}^*\)</span>, which consists of
all linear functionals defined on the space <span
class="math inline">\(\mathcal{V}\)</span>.</p>
<h3 data-number="2.3.1" id="solution-procedure">Solution procedure</h3>
<p>In summary, the solution procedure for <span
class="math inline">\((\ddagger_h)\)</span> is this:</p>
<ol type="1">
<li>Assemble the matrix <span
class="math inline">\(A^{(h)}\)</span>.</li>
<li>Assemble the right-hand-side vector <span
class="math inline">\(\boldsymbol{b}^{(h)}\)</span>.</li>
<li>Solve the linear system <span class="math inline">\(A^{(h)}
\boldsymbol{u}^{(h)} = \boldsymbol{b}^{(h)}\)</span> for <span
class="math inline">\(\boldsymbol{u}^{(h)}\)</span>.</li>
<li>Reconstruct the solution <span class="math inline">\(u_h(x)\)</span>
from the dof-vector <span
class="math inline">\(\boldsymbol{u}^{(h)}\)</span> according to the
expansion in <span class="math inline">\((\star)\)</span>.</li>
</ol>
<p>In the rest of this course we will discuss how each of these steps
can be implemented in Python. For the solution of the linear algebra
system we will use the <a href="https://petsc.org/">PETSc</a>
library.</p>
</body>
</html>
